{% extends 'base.html' %}

{% block content %}
<div class="game-info">
    <div>地雷: <span id="mine-count">{{ game.mines }}</span></div>
    <div>标记: <span id="flag-count">0</span></div>
    <div>时间: <span id="time">{{ used_time }}</span>秒</div>
</div>

<div class="controls">
    <button id="restart">重新开始</button>
    <button onclick="window.location.href='{% url "game:new_game" %}'">新游戏</button>
    <div id="start-time" style="margin-top: 10px; font-size: 14px; color: #666;">
        {% if start_time_str %}游戏开始时间: {{ start_time_str }}{% endif %}
    </div>
</div>

<div class="board-container">
    <div class="board" id="board"></div>
</div>

<div class="message" id="message"></div>

<script>
    // 从Django传递的数据
    const gameData = {
        gameId: {{ game.id }},
        rows: {{ rows }},
        cols: {{ cols }},
        mines: {{ game.mines }},
        stateMatrix: {{ state_matrix|safe }},
        minesMatrix: {{ mines_matrix|safe }},
        usedTime: parseFloat("{{ used_time }}"),
        gameStarted: "{{ start_time_str }}" !== "",
        gameEnded: {{ game.end_time|yesno:"true,false" }}
    };
    
    // 游戏状态
    let gameState = {
        gameId: gameData.gameId,
        rows: gameData.rows,
        cols: gameData.cols,
        totalMines: gameData.mines,
        board: [],
        flagCount: 0,
        revealedCount: 0,
        gameOver: false,
        gameStarted: gameData.gameStarted,
        gameEnded: gameData.gameEnded
    };
    
    // DOM 元素
    const boardElement = document.getElementById('board');
    const mineCountElement = document.getElementById('mine-count');
    const flagCountElement = document.getElementById('flag-count');
    const timeElement = document.getElementById('time');
    const messageElement = document.getElementById('message');
    const restartButton = document.getElementById('restart');
    
    // 初始化游戏
    function initGame() {
        // 重置状态
        gameState.flagCount = 0;
        gameState.revealedCount = 0;
        gameState.gameOver = false;
        
        // 初始化棋盘数据结构
        gameState.board = [];
        for (let i = 0; i < gameState.rows; i++) {
            gameState.board[i] = [];
            for (let j = 0; j < gameState.cols; j++) {
                const state = parseInt(gameData.stateMatrix[i][j]);
                const isMine = parseInt(gameData.minesMatrix[i][j]) === 1;
                
                gameState.board[i][j] = {
                    isMine: isMine,
                    isRevealed: state === 1,
                    isFlagged: state === 2,
                    neighborMines: 0
                };
                
                if (state === 1) gameState.revealedCount++;
                if (state === 2) gameState.flagCount++;
            }
        }
        
        // 计算邻居地雷数
        for (let i = 0; i < gameState.rows; i++) {
            for (let j = 0; j < gameState.cols; j++) {
                if (!gameState.board[i][j].isMine) {
                    gameState.board[i][j].neighborMines = countNeighborMines(i, j);
                }
            }
        }
        
        // 检查游戏状态
        checkGameStatus();
        
        // 更新UI
        updateUI();
        updateCounters();
    }
    
    // 计算周围地雷数
    function countNeighborMines(row, col) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const newRow = row + i;
                const newCol = col + j;
                if (newRow >= 0 && newRow < gameState.rows && 
                    newCol >= 0 && newCol < gameState.cols && 
                    gameState.board[newRow][newCol].isMine) {
                    count++;
                }
            }
        }
        return count;
    }
    
    // 更新UI
    function updateUI() {
        // 清空棋盘
        boardElement.innerHTML = '';
        
        // 设置网格
        boardElement.style.gridTemplateColumns = `repeat(${gameState.cols}, 30px)`;
        boardElement.style.gridTemplateRows = `repeat(${gameState.rows}, 30px)`;
        
        // 创建格子
        for (let i = 0; i < gameState.rows; i++) {
            for (let j = 0; j < gameState.cols; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                
                const cellData = gameState.board[i][j];
                
                if (cellData.isRevealed) {
                    cell.classList.add('revealed');
                    if (cellData.isMine) {
                        cell.classList.add('mine');
                        cell.textContent = '💣';
                    } else if (cellData.neighborMines > 0) {
                        cell.textContent = cellData.neighborMines;
                        cell.classList.add(`number-${cellData.neighborMines}`);
                    }
                } else if (cellData.isFlagged) {
                    cell.classList.add('flagged');
                    cell.textContent = '🚩';
                }
                
                // 只有游戏未结束时才添加事件监听
                if (!gameState.gameOver && !gameState.gameEnded) {
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(i, j);
                    });
                    
                    // 添加中键点击事件（点开一片）
                    cell.addEventListener('mousedown', (e) => {
                        if (e.button === 1) { // 中键
                            e.preventDefault();
                            handleMiddleClick(i, j);
                        }
                    });
                    
                    // 添加双击事件（点开一片）
                    cell.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        handleMiddleClick(i, j);
                    });
                }
                
                boardElement.appendChild(cell);
            }
        }
    }
    
    // 更新计数器
    function updateCounters() {
        flagCountElement.textContent = gameState.flagCount;
        const remainingMines = gameState.totalMines - gameState.flagCount;
        mineCountElement.textContent = Math.max(0, remainingMines);
    }
    
    // 发送动作到服务器
    async function sendAction(row, col, action) {
        try {
            const formData = new FormData();
            formData.append('x', row);
            formData.append('y', col);
            formData.append('act', action);
            formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
            
            const response = await fetch(`/game/${gameState.gameId}/action/`, {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                location.reload();
            }
        } catch (error) {
            console.error('发送动作失败:', error);
        }
    }
    
    // 发送批量动作到服务器
    async function sendBatchAction(actions) {
        try {
            const formData = new FormData();
            formData.append('batch_actions', JSON.stringify(actions));
            formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
            
            const response = await fetch(`/game/${gameState.gameId}/action/`, {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                location.reload();
            }
        } catch (error) {
            console.error('发送批量动作失败:', error);
        }
    }
    
    // 处理格子点击
    function handleCellClick(row, col) {
        if (gameState.gameOver || gameState.gameEnded) return;
        
        const cell = gameState.board[row][col];
        if (cell.isFlagged || cell.isRevealed) return;
        
        // 发送打开动作到服务器
        sendAction(row, col, 'open');
    }
    
    // 处理右键点击
    function handleRightClick(row, col) {
        if (gameState.gameOver || gameState.gameEnded) return;
        
        const cell = gameState.board[row][col];
        if (cell.isRevealed) return;
        
        // 发送标记动作到服务器
        sendAction(row, col, 'flag');
    }
    
    // 处理中键/双击（点开一片）
    function handleMiddleClick(row, col) {
        if (gameState.gameOver || gameState.gameEnded) return;
        
        const cell = gameState.board[row][col];
        if (!cell.isRevealed || cell.isMine) return;
        
        // 计算周围标记的地雷数
        let flaggedCount = 0;
        const neighbors = [];
        
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const newRow = row + i;
                const newCol = col + j;
                
                if (newRow >= 0 && newRow < gameState.rows && 
                    newCol >= 0 && newCol < gameState.cols && 
                    !(i === 0 && j === 0)) {
                    
                    const neighbor = gameState.board[newRow][newCol];
                    neighbors.push({row: newRow, col: newCol, cell: neighbor});
                    
                    if (neighbor.isFlagged) {
                        flaggedCount++;
                    }
                }
            }
        }
        
        // 如果标记数等于该格子的数字，则打开所有未标记的邻居
        if (flaggedCount === cell.neighborMines) {
            const actions = [];
            
            for (const neighbor of neighbors) {
                if (!neighbor.cell.isRevealed && !neighbor.cell.isFlagged) {
                    actions.push({
                        x: neighbor.row,
                        y: neighbor.col,
                        act: 'open'
                    });
                }
            }
            
            if (actions.length > 0) {
                sendBatchAction(actions);
            }
        }
    }
    
    // 检查游戏状态
    function checkGameStatus() {
        let hasRevealedMine = false;
        let totalSafeCells = gameState.rows * gameState.cols - gameState.totalMines;
        
        // 检查是否踩到地雷
        for (let i = 0; i < gameState.rows; i++) {
            for (let j = 0; j < gameState.cols; j++) {
                const cell = gameState.board[i][j];
                if (cell.isRevealed && cell.isMine) {
                    hasRevealedMine = true;
                    break;
                }
            }
            if (hasRevealedMine) break;
        }
        
        if (hasRevealedMine) {
            gameOver(false);
        } else if (gameState.revealedCount === totalSafeCells) {
            gameOver(true);
        }
    }
    
    // 游戏结束
    function gameOver(isWin) {
        gameState.gameOver = true;
        
        if (isWin) {
            messageElement.textContent = `恭喜你赢了！用时 ${gameData.usedTime.toFixed(2)} 秒`;
            messageElement.classList.add('win');
        } else {
            messageElement.textContent = '很遗憾，你输了！';
            messageElement.classList.add('lose');
        }
        
        updateUI();
    }
    
    // 重新开始按钮
    restartButton.addEventListener('click', () => {
        window.location.href = `/game/${gameState.gameId}/`;
    });
    
    // 初始化游戏
    initGame();
</script>

<!-- CSRF token for AJAX requests -->
{% csrf_token %}
{% endblock %}