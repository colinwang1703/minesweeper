{% extends 'base.html' %}

{% block content %}
<div class="game-info">
    <div>åœ°é›·: <span id="mine-count">{{ game.mines }}</span></div>
    <div>æ ‡è®°: <span id="flag-count">0</span></div>
    <div>æ—¶é—´: <span id="time">0.00</span>ç§’</div>
    <div>è§‚ä¼—: <span id="spectator-count">1</span>äºº</div>
</div>

<div class="controls">
    <button id="new-game" onclick="window.location.href='{% url "game:new_game" %}'">æ–°æ¸¸æˆ</button>
    <div id="start-time" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
</div>

<div class="board-container">
    <div class="board" id="board"></div>
</div>

<div class="message" id="message"></div>

<!-- è§‚ä¼—èŠå¤©åŒºåŸŸ -->
<div class="spectator-panel" id="spectator-panel">
    <div class="chat-messages" id="chat-messages"></div>
    <div class="chat-input">
        <input type="text" id="chat-input" placeholder="å‘é€æ¶ˆæ¯..." maxlength="200">
        <button id="send-chat">å‘é€</button>
    </div>
</div>

<style>
.status-win {
    color: #4CAF50;
    font-weight: bold;
    animation: celebrate 2s ease-in-out;
}

.status-lose {
    color: #f44336;
    font-weight: bold;
}

@keyframes celebrate {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.1); }
    50% { transform: scale(1.05); }
    75% { transform: scale(1.1); }
}

.message.win {
    background: linear-gradient(45deg, #4CAF50, #45a049);
    color: white;
    padding: 15px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    text-align: center;
    margin: 20px 0;
    animation: winAnimation 3s ease-in-out;
}

.message.lose {
    background: linear-gradient(45deg, #f44336, #da190b);
    color: white;
    padding: 15px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    text-align: center;
    margin: 20px 0;
}

@keyframes winAnimation {
    0% { transform: scale(0.8); opacity: 0; }
    20% { transform: scale(1.1); opacity: 1; }
    40% { transform: scale(0.95); }
    60% { transform: scale(1.05); }
    80% { transform: scale(0.98); }
    100% { transform: scale(1); }
}

.spectator-panel {
    margin-top: 20px;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 10px;
    max-height: 300px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 10px;
    min-height: 200px;
    border: 1px solid #eee;
    padding: 10px;
    border-radius: 4px;
    background: #f9f9f9;
}

.chat-input {
    display: flex;
    gap: 10px;
}

.chat-input input {
    flex: 1;
    padding: 5px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.chat-input button {
    padding: 5px 15px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.chat-message {
    margin-bottom: 8px;
    padding: 5px;
    border-radius: 4px;
}

.chat-message.system {
    background: #e3f2fd;
    color: #1976d2;
    font-style: italic;
}

.chat-message.user {
    background: #f3e5f5;
}

.connection-status {
    padding: 5px 10px;
    border-radius: 4px;
    margin: 10px 0;
    text-align: center;
}

.connection-status.connected {
    background: #d4edda;
    color: #155724;
}

.connection-status.disconnected {
    background: #f8d7da;
    color: #721c24;
}
</style>

<script>
    // æ¸¸æˆæ•°æ®
    let GAME_DATA = {
        id: {{ game.id }},
        rows: {{ game.rows }},
        cols: {{ game.cols }},
        mines: {{ game.mines }},
        state: {{ state_matrix|safe }},
        mines_matrix: {{ mines_matrix|safe }},
        is_completed: {{ game.is_completed|yesno:"true,false" }},
        is_success: {{ game.is_success|yesno:"true,false" }},
        used_time: parseFloat("{{ used_time }}"),
        is_owner: {% if user == game.user %}true{% else %}false{% endif %}
    };
    
    // WebSocketè¿æ¥
    let gameSocket;
    let connectionStatus = document.createElement('div');
    connectionStatus.className = 'connection-status disconnected';
    connectionStatus.textContent = 'æ­£åœ¨è¿æ¥...';
    document.querySelector('.game-info').appendChild(connectionStatus);
    
    // DOMå…ƒç´ 
    const board = document.getElementById('board');
    const flagCountEl = document.getElementById('flag-count');
    const mineCountEl = document.getElementById('mine-count');
    const timeEl = document.getElementById('time');
    const messageEl = document.getElementById('message');
    const spectatorCountEl = document.getElementById('spectator-count');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendChatBtn = document.getElementById('send-chat');
    
    let flagCount = 0;
    let spectatorCount = 1;
    let timeUpdateInterval;
    
    // åˆå§‹åŒ–WebSocketè¿æ¥
    function initWebSocket() {
        const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
        const wsPath = `${wsScheme}://${window.location.host}/ws/game/${GAME_DATA.id}/`;
        
        gameSocket = new WebSocket(wsPath);
        
        gameSocket.onopen = function(e) {
            console.log('WebSocketè¿æ¥å·²å»ºç«‹');
            connectionStatus.className = 'connection-status connected';
            connectionStatus.textContent = 'ğŸŸ¢ å®æ—¶è¿æ¥';
        };
        
        gameSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            handleWebSocketMessage(data);
        };
        
        gameSocket.onclose = function(e) {
            console.log('WebSocketè¿æ¥å·²å…³é—­');
            connectionStatus.className = 'connection-status disconnected';
            connectionStatus.textContent = 'ğŸ”´ è¿æ¥æ–­å¼€';
            
            // å°è¯•é‡è¿
            setTimeout(() => {
                console.log('å°è¯•é‡æ–°è¿æ¥...');
                initWebSocket();
            }, 3000);
        };
        
        gameSocket.onerror = function(e) {
            console.error('WebSocketé”™è¯¯:', e);
        };
    }
    
    // æ›´æ–°å•ä¸ªæ ¼å­æ˜¾ç¤º
    function updateCellDisplay(cell, state, isMine, i, j) {
        console.log(`updateCellDisplayè¢«è°ƒç”¨: [${i}, ${j}], state: ${state}, isMine: ${isMine}`);
        
        // ä¿å­˜åŸæœ‰çš„äº‹ä»¶ç›‘å¬å™¨
        const onclick = cell.onclick;
        const oncontextmenu = cell.oncontextmenu;
        const onmousedown = cell.onmousedown;
        
        cell.className = 'cell';
        cell.textContent = '';
        
        if (state === 2) {
            cell.classList.add('flagged');
            cell.textContent = 'ğŸš©';
            console.log(`æ ¼å­ [${i}, ${j}] è®¾ç½®ä¸ºæ ‡è®°çŠ¶æ€`);
        } else if (state === 1) {
            cell.classList.add('revealed');
            if (isMine) {
                cell.classList.add('mine');
                cell.textContent = 'ğŸ’£';
                console.log(`æ ¼å­ [${i}, ${j}] æ˜¾ç¤ºä¸ºåœ°é›·`);
            } else {
                const count = countNeighborMines(i, j);
                if (count > 0) {
                    cell.textContent = count;
                    cell.classList.add(`number-${count}`);
                    console.log(`æ ¼å­ [${i}, ${j}] æ˜¾ç¤ºæ•°å­—: ${count}`);
                } else {
                    console.log(`æ ¼å­ [${i}, ${j}] æ˜¾ç¤ºä¸ºç©ºç™½`);
                }
            }
        } else {
            console.log(`æ ¼å­ [${i}, ${j}] ä¿æŒæœªæ­å¼€çŠ¶æ€`);
        }
        
        // æ¢å¤äº‹ä»¶ç›‘å¬å™¨
        cell.onclick = onclick;
        cell.oncontextmenu = oncontextmenu;
        cell.onmousedown = onmousedown;
    }
    
    // æ›´æ–°æ•´ä¸ªæ£‹ç›˜
    function updateBoard() {
        console.log('updateBoardè¢«è°ƒç”¨');
        console.log('å½“å‰GAME_DATA.state:', GAME_DATA.state);
        
        flagCount = 0; // é‡ç½®flagè®¡æ•°
        for (let i = 0; i < GAME_DATA.rows; i++) {
            for (let j = 0; j < GAME_DATA.cols; j++) {
                const cell = board.children[i * GAME_DATA.cols + j];
                if (!cell) {
                    console.error(`æ‰¾ä¸åˆ°æ ¼å­ [${i}, ${j}]`);
                    continue;
                }
                
                const state = GAME_DATA.state[i][j];
                const isMine = GAME_DATA.mines_matrix[i][j];
                
                console.log(`æ›´æ–°æ ¼å­ [${i}, ${j}], state: ${state}, isMine: ${isMine}`);
                updateCellDisplay(cell, state, isMine, i, j);
                
                // ç»Ÿè®¡flagæ•°é‡
                if (state === 2) {
                    flagCount++;
                }
            }
        }
        updateCounters();
        checkGameStatus(); // æ·»åŠ æ¸¸æˆçŠ¶æ€æ£€æŸ¥
    }
    
    // åˆå§‹åŒ–æ£‹ç›˜
    function initBoard() {
        board.style.gridTemplateColumns = `repeat(${GAME_DATA.cols}, 30px)`;
        board.innerHTML = '';
        
        const fragment = document.createDocumentFragment();
        flagCount = 0;
        
        for (let i = 0; i < GAME_DATA.rows; i++) {
            for (let j = 0; j < GAME_DATA.cols; j++) {
                const cell = createCell(i, j);
                fragment.appendChild(cell);
            }
        }
        
        board.appendChild(fragment);
        updateCounters();
        checkGameStatus(); // æ·»åŠ æ¸¸æˆçŠ¶æ€æ£€æŸ¥
    }
    
    // åˆ›å»ºå•ä¸ªæ ¼å­
    function createCell(i, j) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = i;
        cell.dataset.col = j;
        
        const state = GAME_DATA.state[i][j];
        const isMine = GAME_DATA.mines_matrix[i][j];
        
        updateCellDisplay(cell, state, isMine, i, j);
        
        // ç»Ÿè®¡flagæ•°é‡
        if (state === 2) {
            flagCount++;
        }
        
        // åªæœ‰æ¸¸æˆæ‰€æœ‰è€…ä¸”æ¸¸æˆæœªå®Œæˆæ—¶æ‰èƒ½æ“ä½œ
        if (GAME_DATA.is_owner && !GAME_DATA.is_completed) {
            cell.onclick = () => handleCellClick(i, j, 'open');
            cell.oncontextmenu = (e) => {
                e.preventDefault();
                handleCellClick(i, j, 'flag');
            };
            cell.onmousedown = (e) => {
                if (e.button === 1) {
                    e.preventDefault();
                    handleMiddleClick(i, j);
                }
            };
        }
        
        return cell;
    }
    
    // å¤„ç†WebSocketæ¶ˆæ¯
    function handleWebSocketMessage(data) {
        console.log('æ”¶åˆ°WebSocketæ¶ˆæ¯:', data); // æ·»åŠ è°ƒè¯•æ—¥å¿—
        
        switch(data.type) {
            case 'connection_established':
                console.log('è¿æ¥å·²å»ºç«‹:', data.message);
                break;
                
            case 'game_state':
                console.log('å¤„ç†game_stateæ¶ˆæ¯');
                updateGameData(data.data);
                initBoard();
                break;
                
            case 'game_update':
                console.log('å¤„ç†game_updateæ¶ˆæ¯');
                console.log('æ›´æ–°å‰çš„GAME_DATA.state:', GAME_DATA.state);
                updateGameData(data.data);
                console.log('æ›´æ–°åçš„GAME_DATA.state:', GAME_DATA.state);
                updateBoard();
                if (data.user) {
                    addChatMessage(`${data.user} è¿›è¡Œäº†æ“ä½œ`, 'system');
                }
                break;
                
            case 'user_joined':
                spectatorCount++;
                spectatorCountEl.textContent = spectatorCount;
                addChatMessage(`${data.user} åŠ å…¥è§‚çœ‹`, 'system');
                break;
                
            case 'user_left':
                spectatorCount = Math.max(1, spectatorCount - 1);
                spectatorCountEl.textContent = spectatorCount;
                addChatMessage(`${data.user} ç¦»å¼€äº†`, 'system');
                break;
                
            case 'chat_message':
                addChatMessage(`${data.user}: ${data.message}`, 'user');
                break;
                
            case 'error':
                console.error('WebSocketé”™è¯¯:', data.message);
                alert(data.message);
                break;
                
            default:
                console.log('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', data.type);
        }
    }
    
    // æ›´æ–°æ¸¸æˆæ•°æ®
    function updateGameData(newData) {
        console.log('updateGameDataè¢«è°ƒç”¨ï¼ŒnewData:', newData);
        
        // å¤„ç†åç«¯å‘é€çš„æ•°æ®æ ¼å¼è½¬æ¢
        if (newData.state_matrix && !newData.state) {
            newData.state = newData.state_matrix;
        }
        if (newData.mines_matrix_data && !newData.mines_matrix) {
            newData.mines_matrix = newData.mines_matrix_data;
        }
        
        GAME_DATA = {...GAME_DATA, ...newData};
        console.log('æ›´æ–°åçš„GAME_DATA:', GAME_DATA);
        
        // æ›´æ–°æ—¶é—´æ˜¾ç¤º
        if (newData.used_time !== undefined) {
            timeEl.textContent = newData.used_time.toFixed(2);
        }
        
        // æ›´æ–°å¼€å§‹æ—¶é—´æ˜¾ç¤º
        if (newData.start_time) {
            const startTime = new Date(newData.start_time);
            document.getElementById('start-time').textContent = 
                `æ¸¸æˆå¼€å§‹æ—¶é—´: ${startTime.toLocaleTimeString()}`;
        }
        
        // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
        checkGameStatus();
    }
    
    // å‘é€æ¸¸æˆåŠ¨ä½œ
    function sendGameAction(actionData) {
        console.log('å‘é€æ¸¸æˆåŠ¨ä½œ:', actionData);
        if (gameSocket.readyState === WebSocket.OPEN) {
            gameSocket.send(JSON.stringify({
                type: 'game_action',
                data: actionData
            }));
        } else {
            alert('è¿æ¥æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢');
        }
    }
    
    // å‘é€èŠå¤©æ¶ˆæ¯
    function sendChatMessage(message) {
        if (gameSocket.readyState === WebSocket.OPEN) {
            gameSocket.send(JSON.stringify({
                type: 'spectator_action',
                data: {
                    type: 'chat',
                    message: message,
                    timestamp: new Date().toISOString()
                }
            }));
        }
    }
    
    // æ·»åŠ èŠå¤©æ¶ˆæ¯
    function addChatMessage(message, type = 'user') {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${type}`;
        messageDiv.textContent = message;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // å¤„ç†æ ¼å­ç‚¹å‡»
    function handleCellClick(row, col, action) {
        console.log(`ç‚¹å‡»æ ¼å­ [${row}, ${col}], åŠ¨ä½œ: ${action}`);
        sendGameAction({
            x: row,
            y: col,
            act: action
        });
    }
    
    // å¤„ç†ä¸­é”®ç‚¹å‡»
    function handleMiddleClick(row, col) {
        const cell = board.children[row * GAME_DATA.cols + col];
        if (!cell.classList.contains('revealed')) return;
        
        const neighborMines = countNeighborMines(row, col);
        let flaggedCount = 0;
        const actions = [];
        
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                
                const newRow = row + i;
                const newCol = col + j;
                
                if (newRow >= 0 && newRow < GAME_DATA.rows && 
                    newCol >= 0 && newCol < GAME_DATA.cols) {
                    
                    const neighborState = GAME_DATA.state[newRow][newCol];
                    
                    if (neighborState === 2) {
                        flaggedCount++;
                    } else if (neighborState === 0) {
                        actions.push({x: newRow, y: newCol, act: 'open'});
                    }
                }
            }
        }
        
        if (flaggedCount === neighborMines && actions.length > 0) {
            sendGameAction({
                batch_actions: actions
            });
        }
    }
    
    // è®¡ç®—é‚»å±…åœ°é›·æ•°
    function countNeighborMines(row, col) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const newRow = row + i, newCol = col + j;
                if (newRow >= 0 && newRow < GAME_DATA.rows && 
                    newCol >= 0 && newCol < GAME_DATA.cols && 
                    GAME_DATA.mines_matrix[newRow][newCol]) {
                    count++;
                }
            }
        }
        return count;
    }
    
    // æ›´æ–°è®¡æ•°å™¨
    function updateCounters() {
        flagCountEl.textContent = flagCount;
        mineCountEl.textContent = Math.max(0, GAME_DATA.mines - flagCount);
    }
    
    // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
    function checkGameStatus() {
        if (GAME_DATA.is_completed) {
            if (GAME_DATA.is_success) {
                messageEl.innerHTML = `ğŸ‰ æ¸¸æˆèƒœåˆ©ï¼ç”¨æ—¶: ${GAME_DATA.used_time.toFixed(2)} ç§’`;
                messageEl.className = 'message win';
            } else {
                messageEl.innerHTML = `ğŸ’¥ æ¸¸æˆå¤±è´¥ï¼`;
                messageEl.className = 'message lose';
                revealAllMines();
            }
        }
    }
    
    // æ˜¾ç¤ºæ‰€æœ‰åœ°é›·
    function revealAllMines() {
        for (let i = 0; i < GAME_DATA.rows; i++) {
            for (let j = 0; j < GAME_DATA.cols; j++) {
                if (GAME_DATA.mines_matrix[i][j] && GAME_DATA.state[i][j] !== 1) {
                    const cell = board.children[i * GAME_DATA.cols + j];
                    cell.classList.add('revealed', 'mine');
                    cell.textContent = 'ğŸ’£';
                }
            }
        }
    }
    
    // èŠå¤©åŠŸèƒ½
    sendChatBtn.addEventListener('click', () => {
        const message = chatInput.value.trim();
        if (message) {
            sendChatMessage(message);
            chatInput.value = '';
        }
    });
    
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendChatBtn.click();
        }
    });
    
    // åˆå§‹åŒ–
    initWebSocket();
    initBoard();
</script>

{% csrf_token %}
{% endblock %}